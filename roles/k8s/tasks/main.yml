---
# Main tasks

### Distro setup

- name: Setup RedHat
  include_tasks: redhat.yml
  when: ansible_os_family|lower == 'redhat'

- name: Setup Debian
  include_tasks: debian.yml
  when: ansible_os_family|lower == 'debian'


### Calico

- name: Check Calico CLI version
  shell: calicoctl version | grep 'Client Version:' | egrep -o 'v[0-9.]+'
  register: calico_version_check
  ignore_errors: true
  changed_when: false

- name: Install Calico CLI
  get_url:
    url: https://github.com/projectcalico/calicoctl/releases/download/v{{calico_version}}/calicoctl
    dest: /usr/local/bin/calicoctl
    mode: 0755
  when: calico_version_check.rc != 0 or calico_version_check.stdout != ("v" + calico_version)

- name: Create Calico CLI config directory
  file:
    path: /etc/calico
    state: directory

- name: Configure Calico CLI
  copy:
    dest: /etc/calico/calicoctl.cfg
    content: |
      apiVersion: projectcalico.org/v3
      kind: CalicoAPIConfig
      metadata:
      spec:
        datastoreType: "kubernetes"
        kubeconfig: "/root/.kube/config"

- name: Check if NetworkManager config directory exists
  stat:
    path: /etc/NetworkManager/conf.d
  register: nm_config_dir

- name: Exclude Calico from NetworkManager
  copy:
    dest: /etc/NetworkManager/conf.d/calico.conf
    content: |
      [keyfile]
      unmanaged-devices=interface-name:cali*;interface-name:tunl*;interface-name:vxlan.calico
  when: nm_config_dir.stat.exists == true


### cert-manager

- name: Check cert-manager CLI version
  shell: cmctl version --client --short | grep 'Client Version:' | egrep -o 'v[0-9.]+'
  register: certmanager_version_check
  ignore_errors: true
  changed_when: false

- name: Install cert-manager CLI
  unarchive:
    remote_src: true
    src: https://github.com/jetstack/cert-manager/releases/download/v{{certmanager_version}}/cmctl-linux-amd64.tar.gz
    dest: /usr/local/bin
    extra_opts: ["cmctl"]
    creates: /usr/local/bin/cmctl
  when: certmanager_version_check.rc != 0 or certmanager_version_check.stdout != ("v" + certmanager_version)


### etcd

- name: Check etcd CLI version
  shell: etcdctl version | grep 'etcdctl version:' | egrep -o '[0-9.]+'
  register: etcd_version_check
  ignore_errors: true
  changed_when: false

- name: Install etcd CLI
  unarchive:
    remote_src: true
    src: https://github.com/etcd-io/etcd/releases/download/v{{etcd_version}}/etcd-v{{etcd_version}}-linux-amd64.tar.gz
    dest: /usr/local/bin
    extra_opts: ["--strip-components=1", "etcd-v{{etcd_version}}-linux-amd64/etcdctl"]
    creates: /usr/local/bin/etcdctl
  when: etcd_version_check.rc != 0 or etcd_version_check.stdout != etcd_version


### Helm

- name: Check Helm version
  shell: helm version --template {% raw %}{{.Version}}{% endraw %}
  register: helm_version_check
  ignore_errors: true
  changed_when: false

- name: Install Helm
  unarchive:
    remote_src: true
    src: https://get.helm.sh/helm-v{{helm_version}}-linux-amd64.tar.gz
    dest: /usr/local/bin
    extra_opts: ["--strip-components=1", "linux-amd64/helm"]
    creates: /usr/local/bin/helm
  when: helm_version_check.rc != 0 or helm_version_check.stdout != ("v" + helm_version)


### Storage

- name: Create containers storage directory
  file:
    path: "{{containers_storage_dir}}"
    mode: 0700
    state: directory

- name: Configure containers storage (runroot)
  lineinfile:
    path: /etc/containers/storage.conf
    regexp: "^runroot = "
    line: "runroot = \"{{containers_storage_dir}}/run\""

- name: Configure containers storage (graphroot)
  lineinfile:
    path: /etc/containers/storage.conf
    regexp: "^graphroot = "
    line: "graphroot = \"{{containers_storage_dir}}/graph\""


### System

- name: Load br_netfilter kernel module
  modprobe:
    name: br_netfilter
  when: "ansible_virtualization_tech_guest is not defined or 'container' not in ansible_virtualization_tech_guest"

- name: Configure sysctl
  sysctl:
    name: "{{item}}"
    value: "1"
  loop:
    - net.ipv4.ip_forward
    - net.bridge.bridge-nf-call-iptables
    - net.bridge.bridge-nf-call-ip6tables
  when: "ansible_virtualization_tech_guest is not defined or 'container' not in ansible_virtualization_tech_guest"

- name: Check if SELinux config exists
  stat:
    path: /etc/selinux/config
  register: selinux_config_file

- name: Disable SELinux
  selinux:
    state: disabled
  when: selinux_config_file.stat.exists == true

- name: Enable services
  service:
    name: "{{item}}"
    enabled: true
    state: started
  loop:
    - crio
    - kubelet
  when: "ansible_virtualization_tech_guest is not defined or 'container' not in ansible_virtualization_tech_guest"


### kubeadm & kubelet

- name: Create kubelet directory
  file:
    path: /var/lib/kubelet
    mode: 0700
    state: directory

- name: Configure registry authentication
  copy:
    dest: /var/lib/kubelet/config.json
    content: "{\"auths\": {{vault_k8s_registry_auths | to_json}}}"
    mode: 0600

- name: Check if kubelet config exists
  stat:
    path: /var/lib/kubelet/config.yaml
  register: kubelet_config_file

- name: Init cluster as master
  shell: "kubeadm init --node-name={{k8s_node_name}} --cri-socket=/var/run/crio/crio.sock --pod-network-cidr={{k8s_pod_cidr}} --service-cidr={{k8s_service_cidr}} --control-plane-endpoint={{k8s_master_host}}:{{k8s_master_port}} --upload-certs"
  when: kubelet_config_file.stat.exists == false and k8s_node_role == 'master'

- name: Join cluster as control plane
  shell: "kubeadm join --node-name={{k8s_node_name}} --cri-socket=/var/run/crio/crio.sock --token {{k8s_join_token}} {{k8s_master_host}}:{{k8s_master_port}} --discovery-token-ca-cert-hash sha256:{{k8s_cert_hash}} --control-plane --certificate-key {{k8s_cert_key}}"
  when: kubelet_config_file.stat.exists == false and k8s_node_role == 'controlplane' and k8s_join_token|length > 0 and k8s_cert_hash|length > 0 and k8s_cert_key|length > 0

- name: Join cluster as worker
  shell: "kubeadm join --node-name={{k8s_node_name}} --cri-socket=/var/run/crio/crio.sock --token {{k8s_join_token}} {{k8s_master_host}}:{{k8s_master_port}} --discovery-token-ca-cert-hash sha256:{{k8s_cert_hash}}"
  when: kubelet_config_file.stat.exists == false and k8s_node_role == 'worker' and k8s_join_token|length > 0 and k8s_cert_hash|length > 0

- name: Check if kubectl admin config exists
  stat:
    path: /etc/kubernetes/admin.conf
  register: kubectl_config_file

- name: Create kubectl config directory for root
  file:
    path: /root/.kube
    state: directory
  when: kubectl_config_file.stat.exists == true

- name: Copy kubectl config for root
  copy:
    dest: /root/.kube/config
    src: /etc/kubernetes/admin.conf
    remote_src: true
  when: kubectl_config_file.stat.exists == true

- name: Allow control plane to schedule pods
  shell: "kubectl taint nodes {{k8s_node_name}} node-role.kubernetes.io/master-"
  ignore_errors: true
  when: kubectl_config_file.stat.exists == true and (k8s_node_role == 'master' or k8s_node_role == 'controlplane')

- name: Configure node labels
  shell: "kubectl label --overwrite nodes {{k8s_node_name}} {{k8s_node_labels}}"
  when: kubectl_config_file.stat.exists == true
